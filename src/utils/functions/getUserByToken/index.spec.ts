// Generated by Qodo Gen

import { IUser } from "@/typing";
import { verify } from "jsonwebtoken";
import { getUserByToken } from ".";

jest.mock("jsonwebtoken");

describe("Get User By Token - Unit Test - Suite", () => {
  const mockUser = { id: "123", name: "Test User" };
  const mockAuthSecret = "test-secret";
  beforeEach(() => {
    (verify as jest.Mock).mockReturnValue(mockUser);
    jest.replaceProperty(process, "env", {
      AUTH_SECRET: mockAuthSecret,
    });
  });

  it("should return user data and access token when valid Bearer token provided", async () => {
    const mockToken = "Bearer abc123";

    const result = await getUserByToken(mockToken);

    expect(verify).toHaveBeenCalledWith("abc123", mockAuthSecret, {
      algorithms: ["HS256"],
    });
    expect(result).toEqual({
      userData: mockUser,
      accessToken: "abc123",
    });
  });

  it("should return null values when empty token provided", async () => {
    const emptyToken = "";

    const result = await getUserByToken(emptyToken);

    expect(result).toEqual({
      userData: null,
      accessToken: null,
    });
  });

  it("should return user data and access token when valid token without Bearer prefix is provided", async () => {
    const mockUser = { id: "123", name: "Test User" };
    const mockToken = "abc123";

    (verify as jest.Mock).mockReturnValue(mockUser);

    const result = await getUserByToken(mockToken);

    expect(verify).toHaveBeenCalledWith("abc123", mockAuthSecret, {
      algorithms: ["HS256"],
    });
    expect(result).toEqual({
      userData: mockUser,
      accessToken: "abc123",
    });
  });

  it("should return user data and access token when valid Bearer token is provided", async () => {
    const mockUser = { id: "123", name: "Test User" };
    const mockToken = "Bearer abc123";

    (verify as jest.Mock).mockReturnValue(mockUser);

    const result = await getUserByToken(mockToken);

    expect(verify).toHaveBeenCalledWith("abc123", mockAuthSecret, {
      algorithms: ["HS256"],
    });
    expect(result).toEqual({
      userData: mockUser,
      accessToken: "abc123",
    });
  });

  it("should cast token payload to IUser type when valid token is provided", async () => {
    const mockUser: IUser = { register: "123", name: "Test User" };
    const mockToken = "Bearer abc123";

    (verify as jest.Mock).mockReturnValue(mockUser);

    const result = await getUserByToken(mockToken);

    expect(verify).toHaveBeenCalledWith("abc123", mockAuthSecret, {
      algorithms: ["HS256"],
    });
    expect(result.userData).toEqual(mockUser);
  });

  it("should use empty string as authToken when AUTH_SECRET is missing", async () => {
    const mockUser = { id: "123", name: "Test User" };
    const mockToken = "Bearer abc123";

    delete process.env.AUTH_SECRET;

    (verify as jest.Mock).mockReturnValue(mockUser);

    const result = await getUserByToken(mockToken);

    expect(verify).toHaveBeenCalledWith("abc123", "", {
      algorithms: ["HS256"],
    });
    expect(result).toEqual({
      userData: mockUser,
      accessToken: "abc123",
    });
  });

  it("should throw an error when JWT signature is invalid", async () => {
    const mockToken = "Bearer invalidToken";

    (verify as jest.Mock).mockImplementation(() => {
      throw new Error("invalid signature");
    });

    await expect(getUserByToken(mockToken)).rejects.toThrow(
      "invalid signature",
    );
  });

  it("should return null for userData and accessToken when token is undefined", async () => {
    const result = await getUserByToken(undefined);
    expect(result).toEqual({
      userData: null,
      accessToken: null,
    });
  });

  it("should throw an error when token is malformed", async () => {
    const malformedToken = "Bearer malformedToken";

    (verify as jest.Mock).mockImplementation(() => {
      throw new Error("Token verification failed");
    });

    await expect(getUserByToken(malformedToken)).rejects.toThrow(
      "Token verification failed",
    );
  });

  it("should throw error when token algorithm is invalid", async () => {
    const mockToken = "Bearer invalidToken";

    (verify as jest.Mock).mockImplementation(() => {
      throw new Error("invalid algorithm");
    });

    await expect(getUserByToken(mockToken)).rejects.toThrow(
      "invalid algorithm",
    );
  });

  it.failing(
    "should return null userData and accessToken when token is expired",
    async () => {
      const mockToken = "Bearer expiredToken";

      (verify as jest.Mock).mockImplementation(() => {
        throw new Error("TokenExpiredError");
      });

      const result = await getUserByToken(mockToken);

      expect(verify).toHaveBeenCalledWith("expiredToken", mockAuthSecret, {
        algorithms: ["HS256"],
      });
      expect(result).toEqual({
        userData: null,
        accessToken: null,
      });
    },
  );
});
